//@version=6
indicator("AvalPV1", shorttitle="APV1", overlay=true)

// ══════════════════════════════════════════════════════════════════════
// 📋 CONFIGURACIÓN Y PARÁMETROS
// ══════════════════════════════════════════════════════════════════════

// --- Parámetros de Cálculo ---
use_automatic_date = input.bool(true, "Use Automatic Date", group="Parameters", tooltip="If true, calculates range from the prior day automatically. If false, uses the 'Selected Date' below.")
nr2_level_type = input.string("Previous Day Close", "NR2 Level Type", options=["Previous Day Close", "Current Day Open"], group="Parameters", tooltip="Select whether NR2 should use the previous day's close or current day's open.")
gap_mode = input.string("Automatic", "Gap Calculation Mode", options=["Automatic", "Manual"], group="Parameters", tooltip="Select whether the gap is calculated automatically or manually.")
manual_gap = input.float(0.0, "Manual Gap", group="Parameters", tooltip="The manual gap value. Only used if Gap Calculation Mode is 'Manual'.")
selected_date = input.time(timestamp("2023-01-01"), "Selected Date", group="Parameters", tooltip="Date for calculating levels (only used if 'Use Automatic Date' is false).")
manual_price = input.float(0.0, "Manual Price", group="Parameters", tooltip="Base price for levels. If 0, uses prior day's close or current day's open based on NR2 Level Type.")

// --- Configuración Visual ---
line_width = input.int(1, "Line Width", minval=1, group="Visuals")
show_labels = input.bool(true, "Show Labels", group="Visuals")

// ══════════════════════════════════════════════════════════════════════
// 🧮 FUNCIONES AUXILIARES
// ══════════════════════════════════════════════════════════════════════

// @function Rounds a value to the nearest quarter.
// @param value The value to round.
// @returns The rounded value.
roundToQuarter(value) =>
    math.round(value * 4) / 4

// @function Draws a price level line and its corresponding label.
// @param price The price value to draw the line at.
// @param line_color The color of the line.
// @param p_text The text for the label.
// @param text_color The color of the label's text.
// @param line_array The array to store the new line object.
// @param label_array The array to store the new label object.
drawLevel(price, line_color, p_text, text_color, line_array, label_array) =>
    line_id = line.new(bar_index, price, bar_index + 1, price, xloc.bar_index, extend.right, line_color, width=line_width)
    array.push(line_array, line_id)
    if show_labels
        label_id = label.new(bar_index, price, p_text, xloc.bar_index, yloc.price, color(na), label.style_label_left, text_color, size=size.normal)
        array.push(label_array, label_id)

// ══════════════════════════════════════════════════════════════════════
// 📊 CÁLCULOS PRINCIPALES
// ══════════════════════════════════════════════════════════════════════

// --- Variables de estado para líneas y etiquetas ---
var line[] all_lines = array.new_line()
var label[] all_labels = array.new_label()

// --- Obtención de datos diarios ---
[prev_day_high, prev_day_low, prev_day_open, prev_day_close] = request.security(syminfo.tickerid, "D", [high[1], low[1], open[1], close[1]], lookahead=barmerge.lookahead_on)

// --- Detección de nuevo día ---
is_new_day = ta.change(dayofmonth)

// --- Lógica de cálculo diario ---
if is_new_day
    // Limpiar objetos del día anterior
    for l in all_lines
        line.delete(l)
    for l in all_labels
        label.delete(l)
    array.clear(all_lines)
    array.clear(all_labels)

    // --- Determinar Rango y Precio Base ---
    float day_range = na
    float base_price = na
    
    // Nota: La lógica de fecha manual no se implementa para alinearse con las prácticas comunes de PineScript.
    if use_automatic_date
        day_range := prev_day_high - prev_day_low
        
        // Aplicar Cálculo de Gap
        if gap_mode == "Automatic"
            gap = math.abs(prev_day_open - prev_day_close)
            day_range += gap
        else // Manual
            day_range += manual_gap

        // Determinar Precio Base para NR2
        if manual_price > 0
            base_price := manual_price
        else if nr2_level_type == "Current Day Open"
            base_price := prev_day_open // Nota: Apertura de la sesión diaria anterior.
        else // Previous Day Close
            base_price := prev_day_close
    
    // --- Calcular todos los niveles ---
    if not na(day_range) and not na(base_price) and day_range > 0
        // Pre-calcular valores comunes
        float half_range = day_range / 2.0
        float q1_level = roundToQuarter(base_price + half_range)
        float q4_level = roundToQuarter(base_price - half_range)
        
        float range_0125 = day_range * 0.125
        float range_0159 = day_range * 0.159
        float range_025 = day_range * 0.25
        float range_0375 = day_range * 0.375
        float range_050 = day_range * 0.50

        // Calcular niveles
        float q2_level = roundToQuarter(q1_level - range_025)
        float q3_level = roundToQuarter(q4_level + range_025)
        float q2_3_level = roundToQuarter(q1_level - range_0375)
        float q3_4_level = roundToQuarter(q4_level + range_0375)
        float nr2_level = roundToQuarter(base_price)
        float tc_level = roundToQuarter(q1_level - range_0125)
        float nr1_level = roundToQuarter(q1_level - range_0159)
        float std1_plus = roundToQuarter(q1_level + range_0125)
        float std2_plus = roundToQuarter(q1_level + range_025)
        float std3_plus = roundToQuarter(q1_level + range_0375)
        float d1_plus = roundToQuarter(q1_level + range_050)
        float nr3_level = roundToQuarter(q4_level + range_0159)
        float tv_level = roundToQuarter(q4_level + range_0125)
        float std1_minus = roundToQuarter(q4_level - range_0125)
        float std2_minus = roundToQuarter(q4_level - range_025)
        float std3_minus = roundToQuarter(q4_level - range_0375)
        float d1_minus = roundToQuarter(q4_level - range_050)

        // ══════════════════════════════════════════════════════════════════════
        // 🎨 VISUALIZACIÓN
        // ══════════════════════════════════════════════════════════════════════
        
        drawLevel(q1_level, color.yellow, "Q1", color.black, all_lines, all_labels)
        drawLevel(q4_level, color.yellow, "Q4", color.black, all_lines, all_labels)
        drawLevel(q2_level, color.new(color.purple, 0), "Q2", color.white, all_lines, all_labels)
        drawLevel(q3_level, color.new(color.purple, 0), "Q3", color.white, all_lines, all_labels)
        drawLevel(q2_3_level, color.green, "Q2/3", color.white, all_lines, all_labels)
        drawLevel(q3_4_level, color.red, "Q3/4", color.white, all_lines, all_labels)
        drawLevel(tc_level, color.green, "TC", color.white, all_lines, all_labels)
        drawLevel(nr1_level, color.new(color.blue, 50), "NR1", color.white, all_lines, all_labels)
        drawLevel(nr2_level, color.new(color.orange, 0), "NR2", color.black, all_lines, all_labels)
        drawLevel(nr3_level, color.new(color.blue, 50), "NR3", color.white, all_lines, all_labels)
        drawLevel(tv_level, color.red, "TV", color.white, all_lines, all_labels)
        drawLevel(std1_plus, color.green, "Std1+", color.white, all_lines, all_labels)
        drawLevel(std2_plus, color.green, "Std2+", color.white, all_lines, all_labels)
        drawLevel(std3_plus, color.green, "Std3+", color.white, all_lines, all_labels)
        drawLevel(d1_plus, color.new(color.orange, 0), "1D+", color.black, all_lines, all_labels)
        drawLevel(std1_minus, color.red, "Std1-", color.white, all_lines, all_labels)
        drawLevel(std2_minus, color.red, "Std2-", color.white, all_lines, all_labels)
        drawLevel(std3_minus, color.red, "Std3-", color.white, all_lines, all_labels)
        drawLevel(d1_minus, color.new(color.orange, 0), "1D-", color.black, all_lines, all_labels)

// --- Mantenimiento de la posición de las etiquetas ---
if show_labels and array.size(all_labels) > 0
    for i = 0 to array.size(all_labels) - 1
        label.set_x(array.get(all_labels, i), bar_index)